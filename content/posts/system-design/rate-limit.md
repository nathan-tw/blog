---
title: "[技術] 各類Rate limit設計"
date: 2022-04-20T16:52:44+08:00
draft: true
tag: ["Rate Limit"]
categories: ["System Design"]
---

## 來自實習的反省

因為工作的需求，需要設計一套rate limit的機制，讓我想起自己曾經在應徵Dcard後端實習時，根據他們的要求設計了一個類似要求Middleware。現在回頭看發現那時果然太年輕了，許多地方都考慮欠周，趁著這次多方研讀，紀錄一下不同的rate limit機制。

## Rate limit的目的？

限制過於頻繁的請求，保證服務的穩定性

## 何謂良好的Rate limit

* 不會拖垮原服務的效能：畢竟目的是優化性能，總不能本末倒置吧。
* 分散式架構下資料的一致性：分散式的服務不會讀取到錯誤的數量，最簡單的解決辦法是只用一個資料庫實例來紀錄請求數量。
* 請求來源的識別能力：假設只對輸入做無差別限制會造成A用戶的請求過多導致B用戶也受到限制，所以要區別是誰發出的請求。

不難直覺的想到，如果用key-value類型的資料庫剛好滿足以上對資料庫的需求，如果剛好有一個這樣的單線程資料庫就太棒了！redis很自然的浮現在我們腦海中，但單線程真的就沒問題了嗎？


## Race condition

其實rate limit對資料庫來說是一個transaction，為了判斷是否超過限制，我們必須讀取一小時/一天內的請求數量，接著紀錄下這次的請求，所以問題出在兩個請求接連對同一資源做讀取時會有其中一者在另一者之後修改資料庫，但這其實是一種判斷錯誤，要解決 get-then-set 造成的 race condition 有幾種方式：

* **為資料庫新增鎖 (Lock)**：有很多實做鎖的方式，[Redis官方](https://redis.io/docs/reference/patterns/distributed-locks/)列出了很多種社群的作法，以及他們自己的Redlock。
* **先set，後get**：不管會不會超過限制，先紀錄下這次的請求再讀取，這樣的副作用是失敗的請求也會記錄下來，在下次請求要讀取數量時也算入其中。

## Rate limit演算法

假設一個用戶每小時只能發送10個請求，接踵而來的問題是我們如何定義一小時？是以整點作為分界嗎？還是以第一個來的請求算起呢？基本上可以分為以下兩種作法

1. Fixed window：
    * 以用戶識別(例如id)作為key，一小時內的請求數量作為value，在Redis中的資料型態就像 `"d729cdae": 2`。
    * 以整點或第一個請求設置到期時間，也就是Redis的TTL，並且在key加上整點的時間戳記，資料就變成了`"d729cdae:2022/05/28 15:00": 2`，無論是15:01還是15:59的請求都會使count+1。
    * 缺點是在window邊界最多可能允許有高達限制兩倍的請求，以上面的例子來說，因為16:00會重置count，所以15:59和16:01都有9個請求是可能發生的情形。
2. Sliding window
    * 每個請求進來時讀前一小時的數量，問題是在Redis要如何有效的達到這件事呢？總不能用Scan整個資料庫吧。
    


