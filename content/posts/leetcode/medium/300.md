---
title: "[Leetcode] 300. Longest Increasing Subsequence"
date: 2022-11-10T07:50:14+08:00
draft: false
categories: ["Leetcode"]
tag: ["Leetcode"]
---

#  [300](https://leetcode.com/problems/longest-increasing-subsequence/)


## 題目描述
Given an integer array `nums`, return the length of the **longest strictly increasing subsequence**.

A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].


## 解法一：DP
建立一個dp array，`dp[i]`代表的是以`nums[i]`做為結尾的seq的最大長度，做法是搜尋 `dp[0]` ~ `dp[i-1]`，找到最大的sub-LIS，將其+1更新`dp[i]`。

```c
// dp[i]=max(dp[j] for j in 0~i-1)
int lengthOfLIS(int* nums, int numsSize){
    int dp[numsSize];
    int max = 1;
    for(int i = 0; i < numsSize; i++) {
        dp[i] = 1;
        for(int j = 0; j < i; j++)
            dp[i] = (nums[i]>nums[j] && dp[i] <= dp[j]) ? dp[j]+1: dp[i];
        max = dp[i]>max ? dp[i] : max;
    }
    return max;
}
```

`TC: n^2`

## 解法二：DP+Binary Search
建立一個dp array，`dp[i]`代表的是長度i的最佳結尾，關於最佳結尾，可以思考 `1,2,3` 和 `1,2,5`誰對於這個題目來說更有未來，肯定是前者吧因為之後出現`4`後者的長度不會再增加了，前者卻可以變成`1,2,3,4`。每個新插入的數只有兩種可能
 * 如果比目前`dp[-1]`（最後一個）大，可以直接串上, e.g., `1,2,3`--插入4-->`1,2,3,4`
 * 如果比`dp[-1]`小，就用bs更新dp， e.g., `1,2,5`--插入4-->`1,2,4`

搜尋的部分參考[這題](https://leetcode.com/problems/search-insert-position/)。最後回傳dp長度即可。

```c c
int lengthOfLIS(int* nums, int numsSize){
    int dp[numsSize];
    int idx = 0;
    for(int i = 0; i < numsSize; i++) {
        if(!idx || (dp[idx-1] < nums[i])) {
            dp[idx] = nums[i];
            idx++;
        } else {
            int l = 0, r = idx-1; 
            while(l <= r) {
                int mid = (l+r) >> 1;
                if(dp[mid] >= nums[i])
                    r = mid-1;
                else
                    l = mid+1;
            }
            dp[l] = nums[i];
        }
    }
    return idx;
}
```

`TC: nlogn`

## 補充
有些語言對二元搜索有標準套件庫的支援，例如C和C++