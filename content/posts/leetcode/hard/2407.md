---
title: "[Leetcode] 2407. Longest Increasing Subsequence II"
date: 2022-11-10T07:50:14+08:00
draft: true
categories: ["Leetcode"]
tag: ["每週 leetcode hard", "Leetcode"]
---

# [2407](https://leetcode.com/problems/longest-increasing-subsequence-ii/)

LIS (longest increasing subsequence) 是一個經典的 dp 問題，題目簡述是，給定一個陣列並允許刪除其中某些元素，能夠構成最長的嚴格遞增陣列的長度是多少？詳細的可以參考 [這題]({{< ref "../medium/300.md" >}})，本題是基於 LIS 的變化，新增了序列中兩個元素的差 `k`。

## 題目描述

You are given an integer array `nums` and an integer `k`.

Find the longest subsequence of nums that meets the following requirements:

-   **The subsequence is strictly increasing and**
-   **The difference between adjacent elements in the subsequence is at most k.**

Return the length of the longest subsequence that meets the requirements.

## 解法一：DP
建立一個dp array，`dp[i]`代表的是以`nums[i]`做為結尾的seq的最大長度，做法是搜尋 `dp[0]` ~ `dp[i-1]`，找到最大的sub-LIS，將其+1更新`dp[i]`。但為了滿足相鄰的元素相減必須比`k`小，需要加入`nums[i]-nums[j] <=k`判斷。

```c
int dp[numsSize];
int max = 1;
for(int i = 0; i < numsSize; i++) {
    dp[i] = 1;
    for(int j = 0; j < i; j++)
        dp[i] = (nums[i]>nums[j] && nums[i]-nums[j] <=k && dp[i] <= dp[j]) ? dp[j]+1: dp[i];
    max = dp[i] > max ? dp[i] : max;
}
return max;
```

`TC: n^2`

## 解法二：DP+Segment Tree
解法一的效能瓶頸是每次的查詢都是`n^2`，為了降低區間查詢的複雜度，可以使用線段樹來降低查詢複雜度，但為了維護樹的結構，單點修改的複雜度也提升了。以下說明線段樹的原理：


```

```
`TC: nlogn`
