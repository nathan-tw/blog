---
title: "[Leetcode] 2407. Longest Increasing Subsequence II"
date: 2022-11-10T07:50:14+08:00
draft: false
categories: ["Leetcode"]
tag: ["每週 leetcode hard", "Leetcode"]
---

LIS (longest increasing subsequence) 是一個經典的 dp 問題，題目簡述是，給定一個陣列並允許刪除其中某些元素，能夠構成最長的嚴格遞增陣列的長度是多少？詳細的可以參考 [這題]({{< ref "../medium/300.md" >}})，本題是基於 LIS 的變化，新增了序列中兩個元素的差 `k`。
<!--more-->

## 題目描述

You are given an integer array `nums` and an integer `k`.

Find the longest subsequence of nums that meets the following requirements:

-   **The subsequence is strictly increasing and**
-   **The difference between adjacent elements in the subsequence is at most k.**

Return the length of the longest subsequence that meets the requirements.



## 解法一：DP
建立一個dp array，`dp[i]`代表的是以`nums[i]`做為結尾的seq的最大長度，做法是搜尋 `dp[0]` ~ `dp[i-1]`，找到最大的sub-LIS，將其+1更新`dp[i]`。但為了滿足相鄰的元素相減必須比`k`小，需要加入`nums[i]-nums[j] <=k`判斷。

```c
int dp[numsSize];
int max = 1;
for(int i = 0; i < numsSize; i++) {
    dp[i] = 1;
    for(int j = 0; j < i; j++)
        dp[i] = (nums[i]>nums[j] && nums[i]-nums[j] <=k && dp[i] <= dp[j]) ? dp[j]+1: dp[i];
    max = dp[i] > max ? dp[i] : max;
}
return max;
```

`TC: n^2`

## 解法二：DP+Segment Tree
解法一的效能瓶頸是每次的查詢都是`n^2`，為了降低區間查詢的複雜度，可以使用線段樹來降低查詢複雜度，但為了維護樹的結構，單點修改的複雜度也提升了。


{{< tabbed-codeblock LIS2 >}}
<!-- tab cpp -->
class SegTree {
public:
    int n;
    vector<int> tree;
    SegTree(int n_): n(n_) {
        tree = vector<int>(n*4);
    }
    int query(int i, int L, int R, int l, int r) {
        if(l == L && r == R) 
            return tree[i];
        int M = (L+R)>>1;
        if(M >= r)
            return query(i*2+1, L, M, l, r);
        else if(M < l)
            return query(i*2+2, M+1, R, l, r);
        return max(query(i*2+1, L, M, l, M), query(i*2+2, M+1, R, M+1, r));
    }
    void modify(int i, int L, int R, int P, int v) {
        if(L==R) {
            tree[i] = max(v, tree[i]);
            return;
        }
        int M = (L+R) >> 1;
        if(M >= P)
            modify(i*2+1, L, M, P, v);
        else modify(i*2+2, M+1, R, P, v);
        tree[i] = max(tree[i*2+1], tree[i*2+2]);
    }
};

class Solution {
public:
    int lengthOfLIS(vector<int>& nums, int k) {
        int n = *max_element(nums.begin(), nums.end());
        auto segTree = SegTree(n);
        for(auto& num: nums) {
            int lower = max(0, num-k);
            int v = segTree.query(0, 0, segTree.n, lower, num-1);
            segTree.modify(0, 0, segTree.n, num, v+1);
        }
        return segTree.tree[0];
    }
};
<!-- endtab -->

<!-- tab go -->
type SegTree []int
func NewSegTree(n int) SegTree {
    return make(SegTree, n)
}

func (s SegTree) Query(l, r, L, R, i int) int {
    if L==l && R==r {
        return s[i]
    }
    M := (L+R)>>1
    if M >= r {
        return s.Query(l, r, L, M, i*2+1)
    } else if M < l {
        return s.Query(l, r, M+1, R, i*2+2)
    }
    return max(s.Query(l, M, L, M, i*2+1), s.Query(M+1, r, M+1, R, i*2+2))
}

func (s SegTree) Update(L, R, P, i, v int)  {
    if L == R {
        s[i] = max(s[i], v)
        return
    }
    M := (L+R)>>1
    if P <= M {
        s.Update(L, M, P, i*2+1, v) 
    } else { 
        s.Update(M+1, R, P, i*2+2, v) 
    }
    s[i] = max(s[i*2+1], s[i*2+2])
}


func lengthOfLIS(nums []int, k int) int {
    m := 0
    for _, num := range nums {
        m = max(m, num)
    }
    tree := NewSegTree(m*4)
    for _, num := range nums {
        lower := max(0, num - k);
        val := tree.Query(lower, num-1, 0, m, 0)
        tree.Update(0, m, num, 0, val+1)
    }
    return tree[0]
}


func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
<!-- endtab -->
{{< /tabbed-codeblock >}}
`TC: nlogn`
