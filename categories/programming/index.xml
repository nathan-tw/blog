<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programming on 林宣佑 | Nathan Lin</title>
    <link>http://nathan-tw.github.io/categories/programming/</link>
    <description>Recent content in Programming on 林宣佑 | Nathan Lin</description>
    <image>
      <url>http://nathan-tw.github.io/papermod-cover.png</url>
      <link>http://nathan-tw.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 21 Jan 2022 06:30:15 -0400</lastBuildDate><atom:link href="http://nathan-tw.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[技術] 深入淺出 linked list</title>
      <link>http://nathan-tw.github.io/posts/programming/linked-list/</link>
      <pubDate>Fri, 21 Jan 2022 06:30:15 -0400</pubDate>
      
      <guid>http://nathan-tw.github.io/posts/programming/linked-list/</guid>
      <description>linked list 是什麼 假設我們有一串有順序性的數組，要以何種形式存入記憶體呢？ 我們操作的虛擬記憶體就像是一格格的櫥窗，工程師在配置使用空間時有兩種常見的方式：
配置一段連續的格子 (Array) 配置不連續的格子，並以額外的格子紀錄順序性 (Linked list) With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory
因為連續的記憶體是可以隨機存取(random access)的，導致兩種配置方式在資料操作上(e.g., 新增、刪除)的時間及空間成本各有不同。
Array vs. Linked list 兩者在記憶體的結構：
Data storage scheme of an array
Data storage scheme of a linked list
Array：造訪第i個元素時因為是隨機存取所以時間複雜度是O(1)，但因為Array內的元素必須是連續的，移除第i個元素時必須將其後的元素通通往前移，因此為O(n)。
Linked list：無法利用連續記憶體的隨機存取特性，造訪第i個元素時必須先造訪1至i-1，因此時間複雜度為O(n)，且因為必須以額外的指標做相連，使得存入相同的資料時較Array耗費空間。好處是空間配置較為彈性，刪除第i個節點時時間複雜度為O(1)，並且不需要在配置空間時固定長度。
比較兩者使用的空間及特性：
Linked List Array 空間 較複雜(需要額外pointer) 較節省 查詢第i個元素 O(n) O(1) 刪除第i個元素 O(1) O(n) 優點 大小可不固定 隨機存取 Dynamic Array 如果array大小固定，python中的list與go中的slice是如何實現？為何不須在一開始給定Array大小，也沒有剛剛提到的固定長度限制？ 其實他們都是維護一個Dynamic Array，簡單來說就是一個包含Array的類別或結構體，空間不夠時再抽換Array。以go為例，slice的結構如下：</description>
    </item>
    
    <item>
      <title>[技術] Worker Pool併發處理模型</title>
      <link>http://nathan-tw.github.io/posts/programming/worker-pool/</link>
      <pubDate>Mon, 19 Apr 2021 05:03:58 -0400</pubDate>
      
      <guid>http://nathan-tw.github.io/posts/programming/worker-pool/</guid>
      <description>前陣子在準備實習的面試，看到別人的心得被問到如何以Golang實做一個Worker Pool，於是自己嘗試寫了一個。
什麼是Worker Pool Worker Pool是一個以multithread組成的任務處理模型，producer產生許多任務，並交由workers並行處理這些任務，最後將任務結果蒐集起來，這樣的作法可以有效的運用電腦資源，並快速處理重複性高且獨立的作業。
Worker Pool 設計 Type 定義 Worker Pool可以有一定數量的Workers(PoolSize)，並且可以指定一次處理的任務數量(tasksSize)，交由tasksChan送給worker，處理後再經由resultsChan存起來，待Results被呼叫時一一取出。而Task則是定義了id, error 和如何process的function。
type Task struct { Id int Err error f func() error } type WorkerPool struct { PoolSize int tasksSize int tasksChan chan Task resultsChan chan Task Results func() []Task } 功能實做 每一個任務處理完都會回傳error，如順利完成則回傳nil，至於任務如何執行則是依據新增任務時給定。
func (task *Task) Do() error { return task.f() Worker Pool是利用buffered channel做任務的通道，所以可以經由Start將worker一一執行起來後，讓worker利用range的特性不斷監聽是否有任務可以做。
func NewWorkerPool(tasks []Task, size int) *WorkerPool { tasksChan, resultsChan := make(chan Task, len(tasks)), make(chan Task, len(tasks)) for _, task := range tasks { tasksChan &amp;lt;- task } close(tasksChan) pool := &amp;amp;WorkerPool{ PoolSize: size, tasksSize: len(tasks), tasksChan: tasksChan, resultsChan: resultsChan, } pool.</description>
    </item>
    
  </channel>
</rss>
