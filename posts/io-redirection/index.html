<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>[技術] 淺談 file descriptor 及 I/O Redirection | 林宣佑 | Nathan Lin</title><meta name=keywords content="Operating System">
<meta name=description content="前言 fprintf(1, &#34;hello world\n&#34;); 你可能好奇過 C 語言fprintf函數中，第一個參數1代表什麼，你也許聽過在 Unix 家族中Everything is a file，可是他究竟代表什麼意思呢？這篇我們想談談究竟什麼是file，以及作業系統如何達到i/o redirection。
什麼是 file  Everything is a file
 先從這句話開始講起，在類 Unix 的設計中，對所有 I/O 資源的近用都是透過資料流的方式，也就是透過 file system 定義的檔案描述檔(file descriptor)來傳輸，當開啟這些資源時就會回傳一個 file descriptor，代表的就是對這個 file 的控制，例如大家熟悉的 System call open:
int open(char *file, int flags) 其中*file代表 path, flags代表 read/write，用法例如：
fd = open(&#34;/tmp/temp&#34;, O_WRONLY|O_CREAT); 那為什麼是回傳一個 int 呢？其實那個 int 就是 file descriptor，因為每個 process 都有一個 fd (file descriptor) table，其中包含了fd flag以及open file entry，根據xv6 book對其的描述是：
 A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to.">
<meta name=author content="Nathan">
<link rel=canonical href=http://nathan-tw.github.io/posts/io-redirection/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://nathan-tw.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://nathan-tw.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://nathan-tw.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://nathan-tw.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://nathan-tw.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.93.0">
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/languages/vim.min.js integrity="sha512-R+0skJxe/D99VHABS3o+p5jRdY5dO/HAyjeKGUO4qaxPg8gHfDcOlvc5V67aMOJLqLVm0qDPDzcMkToT4o7Rlg==" crossorigin=anonymous referrerpolicy=no-referrer></script><meta property="og:title" content="[技術] 淺談 file descriptor 及 I/O Redirection">
<meta property="og:description" content="前言 fprintf(1, &#34;hello world\n&#34;); 你可能好奇過 C 語言fprintf函數中，第一個參數1代表什麼，你也許聽過在 Unix 家族中Everything is a file，可是他究竟代表什麼意思呢？這篇我們想談談究竟什麼是file，以及作業系統如何達到i/o redirection。
什麼是 file  Everything is a file
 先從這句話開始講起，在類 Unix 的設計中，對所有 I/O 資源的近用都是透過資料流的方式，也就是透過 file system 定義的檔案描述檔(file descriptor)來傳輸，當開啟這些資源時就會回傳一個 file descriptor，代表的就是對這個 file 的控制，例如大家熟悉的 System call open:
int open(char *file, int flags) 其中*file代表 path, flags代表 read/write，用法例如：
fd = open(&#34;/tmp/temp&#34;, O_WRONLY|O_CREAT); 那為什麼是回傳一個 int 呢？其實那個 int 就是 file descriptor，因為每個 process 都有一個 fd (file descriptor) table，其中包含了fd flag以及open file entry，根據xv6 book對其的描述是：
 A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://nathan-tw.github.io/posts/io-redirection/">
<meta property="og:image" content="http://nathan-tw.github.io/images/io-redirection/direction.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-07-07T01:55:05-04:00">
<meta property="article:modified_time" content="2021-07-07T01:55:05-04:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="http://nathan-tw.github.io/images/io-redirection/direction.jpg">
<meta name=twitter:title content="[技術] 淺談 file descriptor 及 I/O Redirection">
<meta name=twitter:description content="前言 fprintf(1, &#34;hello world\n&#34;); 你可能好奇過 C 語言fprintf函數中，第一個參數1代表什麼，你也許聽過在 Unix 家族中Everything is a file，可是他究竟代表什麼意思呢？這篇我們想談談究竟什麼是file，以及作業系統如何達到i/o redirection。
什麼是 file  Everything is a file
 先從這句話開始講起，在類 Unix 的設計中，對所有 I/O 資源的近用都是透過資料流的方式，也就是透過 file system 定義的檔案描述檔(file descriptor)來傳輸，當開啟這些資源時就會回傳一個 file descriptor，代表的就是對這個 file 的控制，例如大家熟悉的 System call open:
int open(char *file, int flags) 其中*file代表 path, flags代表 read/write，用法例如：
fd = open(&#34;/tmp/temp&#34;, O_WRONLY|O_CREAT); 那為什麼是回傳一個 int 呢？其實那個 int 就是 file descriptor，因為每個 process 都有一個 fd (file descriptor) table，其中包含了fd flag以及open file entry，根據xv6 book對其的描述是：
 A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://nathan-tw.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[技術] 淺談 file descriptor 及 I/O Redirection","item":"http://nathan-tw.github.io/posts/io-redirection/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[技術] 淺談 file descriptor 及 I/O Redirection","name":"[技術] 淺談 file descriptor 及 I\/O Redirection","description":"前言 fprintf(1, \u0026#34;hello world\\n\u0026#34;); 你可能好奇過 C 語言fprintf函數中，第一個參數1代表什麼，你也許聽過在 Unix 家族中Everything is a file，可是他究竟代表什麼意思呢？這篇我們想談談究竟什麼是file，以及作業系統如何達到i/o redirection。\n什麼是 file  Everything is a file\n 先從這句話開始講起，在類 Unix 的設計中，對所有 I/O 資源的近用都是透過資料流的方式，也就是透過 file system 定義的檔案描述檔(file descriptor)來傳輸，當開啟這些資源時就會回傳一個 file descriptor，代表的就是對這個 file 的控制，例如大家熟悉的 System call open:\nint open(char *file, int flags) 其中*file代表 path, flags代表 read/write，用法例如：\nfd = open(\u0026#34;/tmp/temp\u0026#34;, O_WRONLY|O_CREAT); 那為什麼是回傳一個 int 呢？其實那個 int 就是 file descriptor，因為每個 process 都有一個 fd (file descriptor) table，其中包含了fd flag以及open file entry，根據xv6 book對其的描述是：\n A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to.","keywords":["Operating System"],"articleBody":"前言 fprintf(1, \"hello world\\n\"); 你可能好奇過 C 語言fprintf函數中，第一個參數1代表什麼，你也許聽過在 Unix 家族中Everything is a file，可是他究竟代表什麼意思呢？這篇我們想談談究竟什麼是file，以及作業系統如何達到i/o redirection。\n什麼是 file  Everything is a file\n 先從這句話開始講起，在類 Unix 的設計中，對所有 I/O 資源的近用都是透過資料流的方式，也就是透過 file system 定義的檔案描述檔(file descriptor)來傳輸，當開啟這些資源時就會回傳一個 file descriptor，代表的就是對這個 file 的控制，例如大家熟悉的 System call open:\nint open(char *file, int flags) 其中*file代表 path, flags代表 read/write，用法例如：\nfd = open(\"/tmp/temp\", O_WRONLY|O_CREAT); 那為什麼是回傳一個 int 呢？其實那個 int 就是 file descriptor，因為每個 process 都有一個 fd (file descriptor) table，其中包含了fd flag以及open file entry，根據xv6 book對其的描述是：\n A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to.\n 從上面的例子中可以理解，一個 process 可以透過打開一個檔案、資料夾、裝置或是製造一個pipe獲取 fd。當然我們也可以複製 fd，透過 system call dup可以達到等等會說的兩個process交換訊息。到這裡你可能會好奇，fd 是如何對資源進行控制的呢？事實上是透過剛剛提到的open file entry去訪問系統層級的open file table，再去inode查找自己需要的資源，以下用一張圖說明兩者的關係：\n  relationship between fd tables, open file table and inode table\n  由此可知，所有的file都指向一個底層的inode。以 xv6 系統為例，在kernel/stat.h是這樣定義inode的資訊：\n#define T_DIR 1 // Directory #define T_FILE 2 // File #define T_DEVICE 3 // Device   struct stat {  int dev; // File system's disk device  uint ino; // Inode number  short type; // Type of file  short nlink; // Number of links to file  uint64 size; // Size of file in bytes  }; 如果要獲取某個fd或是某個file所指向的inode資訊，我們可以使用以下兩個system call：\nint fstat(int fd, struct stat *st) int stat(char *file, struct stat *st) fstat是用fd獲取inode資訊，stat則是獲取某個path的inode資訊，而stat資訊則會被放入*st中，根據執行後的st.type，我們可以知道目前使用的資源是file, directory或是device。到這裡可能會開始困惑，為什麼要那麼麻煩呢？這樣的設計有什麼好處？下一篇我們會談到檔案系統的設計。\nI/O redirection 和 stdin, stdout, stderr int fprintf(FILE *stream, const char *format, ...) 有人可能會問不同process對同一個file做open會得到一樣的fd嗎？如同前面所說fd table是每個process各自擁有的，所以理論上會不同(或碰巧相同)，但有些情況卻不是碰巧，要了解原因必須先回答開頭的問題，fprintf中第一個參數1是什麼呢？相信很多人已經猜到，答案便是fd1，因為POSIX  的定義是process在啟動時會先開啟三個stream: stdin, stdout, stderr，也就是我們剛剛說的fd 0, 1, 2，預設是分別連接到用戶的終端設備，通常就是鍵盤和螢幕啦，如同下圖表示：\n  stdin, stdout, stderr\n  但也不是所有process都是這樣預設，因為如果經由一個parent processfork得到的child process，將會複製parent的fd table，這也是達成redirection的重點，process在安排fd時有一個原則：\n 以尚未被使用的最小int作為新的fd\n 所以我們可以透過抽換fd 0, 1, 2的值去完成redirection，舉我們常使用的cat command來說，簡單的code其實是：\nchar *argv[2]; argv[0] = \"cat\"; argv[1] = 0; if (fork()==0) { // child process  close(0); // 把fd0關掉  // 把指向input.txt資源的fd放在fd table 0的位置 (因為剛才0被關掉，所以最小是0)  open(\"input.txt\", O_RDONLY);  exec(\"cat\", argv); } 上面的例子是在shell執行cat 的簡單範例，因為shell本身也是一個process，所以透過fork去執行其他process時才有機會抽換fd 0, 1, 2，當fork回傳0代表示child process，這也是為什麼fork和exec要分成兩個system call，如果沒辦法抽換stdin, stdout和stderr，i/o就沒有彈性，也就是cat只能吃到shell的輸入，無法吃一個file作為輸入。既然child會複製parent，而我們又可以抽換他，因此偉大的pipe程式(|)也被人發明出來，以簡單的指令echo \"hello world\" | wc為例：\nint p[2]; char *argv[2];  argv[0] = \"wc\"; argv[1] = 0;  pipe(p); // 創建一個pipe，將read/write fd分別放在p[0], p[1] if(fork()==0) { // child process  close(0); // 關掉從parent複製來的stdin  dup(p[0]); // 把pipe的read fd複製一份放到fd0  close(p[0]); // pipe用不到了便關掉  close(p[1]);  exec(\"/bin/wc\", argv); // wc會從stdin讀東西，目前stdin是剛剛設的read pipe } else {  close(p[0]);  write(p[1], \"hello world\\n\", 12); // 把\"hello world\"寫進write pipe  close(p[1]); } 經由pipe串接不同的process，原本用法單調的程式就可以有許多組合技！下一篇寫file system對不同層的設計，讓我們如此方便的使用Everything is a file的概念。\n心得 因為很常使用linux，但對linux卻一直是一知半解，所以才決定寫這篇。但寫的時候很怕出錯，許多細節都更深入的查資料，還是有許多地方自己也看不懂的，如果有任何錯誤也歡迎在底下留言～\nReference  宅色夫老師筆記: https://hackmd.io/@sysprog/c-stream-io?type=view Redirection-in-bash: https://blog.hexrabbit.io/2019/10/22/Redirection-in-bash/ Ubuntu manual page: http://manpages.ubuntu.com/manpages/bionic/zh_TW/man3/stdin.3.html  ","wordCount":"323","inLanguage":"en","image":"http://nathan-tw.github.io/images/io-redirection/direction.jpg","datePublished":"2021-07-07T01:55:05-04:00","dateModified":"2021-07-07T01:55:05-04:00","author":{"@type":"Person","name":"Nathan"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://nathan-tw.github.io/posts/io-redirection/"},"publisher":{"@type":"Organization","name":"林宣佑 | Nathan Lin","logo":{"@type":"ImageObject","url":"http://nathan-tw.github.io/favicon.ico"}}}</script>
</head><body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header>
<nav class=nav>
<div class=logo>
<a href=http://nathan-tw.github.io/ accesskey=h title="林宣佑 | Nathan Lin (Alt + H)">林宣佑 | Nathan Lin</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div><ul id=menu>
<li>
<a href=http://nathan-tw.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/about/ title=About>
<span>About</span>
</a>
</li></ul></nav></header><main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://nathan-tw.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://nathan-tw.github.io/posts/>Posts</a></div><h1 class=post-title>
[技術] 淺談 file descriptor 及 I/O Redirection
</h1><div class=post-meta>July 7, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Nathan
</div></header><figure class=entry-cover><img loading=lazy src=http://nathan-tw.github.io/images/io-redirection/direction.jpg alt>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div></summary>
<div class=inner><ul>
<li>
<a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li>
<a href=#%e4%bb%80%e9%ba%bc%e6%98%af-file aria-label="什麼是 file">什麼是 file</a></li><li>
<a href=#io-redirection-%e5%92%8c-stdin-stdout-stderr aria-label="I/O redirection 和 stdin, stdout, stderr">I/O redirection 和 stdin, stdout, stderr</a></li><li>
<a href=#%e5%bf%83%e5%be%97 aria-label=心得>心得</a></li><li>
<a href=#reference aria-label=Reference>Reference</a>
</li></ul></div></details>
</div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>fprintf(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;hello world</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><p>你可能好奇過 C 語言<code>fprintf</code>函數中，第一個參數<code>1</code>代表什麼，你也許聽過在 Unix 家族中<strong>Everything is a file</strong>，可是他究竟代表什麼意思呢？這篇我們想談談究竟什麼是<code>file</code>，以及作業系統如何達到<code>i/o redirection</code>。</p><h2 id=什麼是-file>什麼是 file<a hidden class=anchor aria-hidden=true href=#什麼是-file>#</a></h2><blockquote>
<p><em>Everything is a file</em></p></blockquote><p>先從這句話開始講起，在類 Unix 的設計中，對所有 I/O 資源的近用都是透過資料流的方式，也就是透過 file system 定義的檔案描述檔(file descriptor)來傳輸，當開啟這些資源時就會回傳一個 file descriptor，代表的就是對這個 file 的控制，例如大家熟悉的 System call <code>open</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> open(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>int</span> flags)
</span></span></code></pre></div><p>其中<code>*file</code>代表 path, <code>flags</code>代表 read/write，用法例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>fd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/tmp/temp&#34;</span>, O_WRONLY<span style=color:#f92672>|</span>O_CREAT);
</span></span></code></pre></div><p>那為什麼是回傳一個 int 呢？其實那個 int 就是 file descriptor，因為每個 process 都有一個 fd (file descriptor) table，其中包含了<code>fd flag</code>以及<code>open file entry</code>，根據<a href=https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf>xv6 book</a>對其的描述是：</p><blockquote>
<p><em>A <strong>file descriptor</strong> is a small integer representing a kernel-managed object that a process may read from or write to.</em></p></blockquote><p>從上面的例子中可以理解，一個 process 可以透過打開一個檔案、資料夾、裝置或是製造一個<code>pipe</code>獲取 fd。當然我們也可以複製 fd，透過 system call <code>dup</code>可以達到等等會說的兩個process交換訊息。到這裡你可能會好奇，fd 是如何對資源進行控制的呢？事實上是透過剛剛提到的<code>open file entry</code>去訪問系統層級的<code>open file table</code>，再去inode查找自己需要的資源，以下用一張圖說明兩者的關係：</p><figure>
<img loading=lazy src=/images/io-redirection/fd_table.png> <figcaption>
<p>relationship between fd tables, open file table and inode table</p></figcaption></figure><p>由此可知，所有的file都指向一個底層的inode。以 xv6 系統為例，在<code>kernel/stat.h</code>是這樣定義inode的資訊：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define T_DIR     1   </span><span style=color:#75715e>// Directory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define T_FILE    2   </span><span style=color:#75715e>// File
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define T_DEVICE  3   </span><span style=color:#75715e>// Device
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>struct</span> stat {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> dev;     <span style=color:#75715e>// File system&#39;s disk device
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   uint ino;    <span style=color:#75715e>// Inode number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>short</span> type;  <span style=color:#75715e>// Type of file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>short</span> nlink; <span style=color:#75715e>// Number of links to file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   uint64 size; <span style=color:#75715e>// Size of file in bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> };
</span></span></code></pre></div><p>如果要獲取某個fd或是某個file所指向的inode資訊，我們可以使用以下兩個system call：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> fstat(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>struct</span> stat <span style=color:#f92672>*</span>st)
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> stat(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>struct</span> stat <span style=color:#f92672>*</span>st)
</span></span></code></pre></div><p><code>fstat</code>是用fd獲取inode資訊，<code>stat</code>則是獲取某個path的inode資訊，而stat資訊則會被放入*st中，根據執行後的st.type，我們可以知道目前使用的資源是file, directory或是device。到這裡可能會開始困惑，為什麼要那麼麻煩呢？這樣的設計有什麼好處？下一篇我們會談到檔案系統的設計。</p><h2 id=io-redirection-和-stdin-stdout-stderr>I/O redirection 和 stdin, stdout, stderr<a hidden class=anchor aria-hidden=true href=#io-redirection-和-stdin-stdout-stderr>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> fprintf(FILE <span style=color:#f92672>*</span>stream, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...)
</span></span></code></pre></div><p>有人可能會問不同process對同一個file做<code>open</code>會得到一樣的fd嗎？如同前面所說fd table是每個process各自擁有的，所以理論上會不同(或碰巧相同)，但有些情況卻不是碰巧，要了解原因必須先回答開頭的問題，<code>fprintf</code>中第一個參數<code>1</code>是什麼呢？相信很多人已經猜到，答案便是fd1，因為POSIX &lt;unistd.h> 的定義是process在啟動時會先開啟三個stream: stdin, stdout, stderr，也就是我們剛剛說的fd 0, 1, 2，預設是分別連接到用戶的終端設備，通常就是鍵盤和螢幕啦，如同下圖表示：</p><figure>
<img loading=lazy src=/images/io-redirection/io_redirection.jpg> <figcaption>
<p>stdin, stdout, stderr</p></figcaption></figure><p>但也不是所有process都是這樣預設，因為如果經由一個parent process<code>fork</code>得到的child process，將會複製parent的fd table，這也是達成redirection的重點，process在安排fd時有一個原則：</p><blockquote>
<p>以尚未被使用的最小int作為新的fd</p></blockquote><p>所以我們可以透過抽換fd 0, 1, 2的值去完成redirection，舉我們常使用的<code>cat &lt; input.txt</code>command來說，簡單的code其實是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>argv[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;cat&#34;</span>;
</span></span><span style=display:flex><span>argv[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (fork()<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// child process
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    close(<span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 把fd0關掉
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 把指向input.txt資源的fd放在fd table 0的位置 (因為剛才0被關掉，所以最小是0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    open(<span style=color:#e6db74>&#34;input.txt&#34;</span>, O_RDONLY); 
</span></span><span style=display:flex><span>    exec(<span style=color:#e6db74>&#34;cat&#34;</span>, argv);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的例子是在shell執行<code>cat &lt; input.txt</code>的簡單範例，因為shell本身也是一個process，所以透過<code>fork</code>去執行其他process時才有機會抽換fd 0, 1, 2，當<code>fork</code>回傳0代表示child process，這也是為什麼<code>fork</code>和<code>exec</code>要分成兩個system call，如果沒辦法抽換stdin, stdout和stderr，i/o就沒有彈性，也就是cat只能吃到shell的輸入，無法吃一個file作為輸入。既然child會複製parent，而我們又可以抽換他，因此偉大的<code>pipe</code>程式(<code>|</code>)也被人發明出來，以簡單的指令<code>echo "hello world" | wc</code>為例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> p[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>argv[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;wc&#34;</span>;
</span></span><span style=display:flex><span>argv[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pipe(p); <span style=color:#75715e>// 創建一個pipe，將read/write fd分別放在p[0], p[1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>(fork()<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// child process
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    close(<span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 關掉從parent複製來的stdin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    dup(p[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>// 把pipe的read fd複製一份放到fd0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    close(p[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>// pipe用不到了便關掉
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    close(p[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    exec(<span style=color:#e6db74>&#34;/bin/wc&#34;</span>, argv); <span style=color:#75715e>// wc會從stdin讀東西，目前stdin是剛剛設的read pipe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    close(p[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    write(p[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;hello world</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>12</span>); <span style=color:#75715e>// 把&#34;hello world&#34;寫進write pipe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    close(p[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>經由<code>pipe</code>串接不同的process，原本用法單調的程式就可以有許多組合技！下一篇寫file system對不同層的設計，讓我們如此方便的使用<strong>Everything is a file</strong>的概念。</p><h2 id=心得>心得<a hidden class=anchor aria-hidden=true href=#心得>#</a></h2><p>因為很常使用linux，但對linux卻一直是一知半解，所以才決定寫這篇。但寫的時候很怕出錯，許多細節都更深入的查資料，還是有許多地方自己也看不懂的，如果有任何錯誤也歡迎在底下留言～</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul>
<li>宅色夫老師筆記: <a href="https://hackmd.io/@sysprog/c-stream-io?type=view">https://hackmd.io/@sysprog/c-stream-io?type=view</a></li><li>Redirection-in-bash: <a href=https://blog.hexrabbit.io/2019/10/22/Redirection-in-bash/>https://blog.hexrabbit.io/2019/10/22/Redirection-in-bash/</a></li><li>Ubuntu manual page: <a href=http://manpages.ubuntu.com/manpages/bionic/zh_TW/man3/stdin.3.html>http://manpages.ubuntu.com/manpages/bionic/zh_TW/man3/stdin.3.html</a></li></ul></div><footer class=post-footer>
<ul class=post-tags>
<li><a href=http://nathan-tw.github.io/tags/operating-system/>Operating System</a></li></ul><nav class=paginav>
<a class=prev href=http://nathan-tw.github.io/posts/university/>
<span class=title>« Prev Page</span>
<br>
<span>[生活] 夏夜夢迴</span>
</a>
<a class=next href=http://nathan-tw.github.io/posts/mapreduce2/>
<span class=title>Next Page »</span>
<br>
<span>[技術] 你不能不知道的軟體架構--MapReduce (二)</span>
</a>
</nav></footer><div class="disqus markdown">
<div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://star67.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></article></main><footer class=footer>
<span>&copy; 2022 <a href=http://nathan-tw.github.io/>林宣佑 | Nathan Lin</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script>
</body></html>