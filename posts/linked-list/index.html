<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>[技術] 深入淺出 linked list | 林宣佑 | Nathan Lin</title><meta name=keywords content>
<meta name=description content="linked list 是什麼 假設我們有一串有順序性的數組，要以何種形式存入記憶體呢？ 我們操作的虛擬記憶體就像是一格格的櫥窗，工程師在配置使用空間時有兩種常見的方式：
 配置一段連續的格子 (Array) 配置不連續的格子，並以額外的格子紀錄順序性 (Linked list)  With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory
     因為連續的記憶體是可以隨機存取(random access)的，導致兩種配置方式在資料操作上(e.g., 新增、刪除)的時間及空間成本各有不同。
Array vs. Linked list 兩者在記憶體的結構：
  Data storage scheme of an array
    Data storage scheme of a linked list
    Array：造訪第i個元素時因為是隨機存取所以時間複雜度是O(1)，但因為Array內的元素必須是連續的，移除第i個元素時必須將其後的元素通通往前移，因此為O(n)。">
<meta name=author content="Nathan">
<link rel=canonical href=http://nathan-tw.github.io/posts/linked-list/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://nathan-tw.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://nathan-tw.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://nathan-tw.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://nathan-tw.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://nathan-tw.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.93.0">
<meta property="og:title" content="[技術] 深入淺出 linked list">
<meta property="og:description" content="linked list 是什麼 假設我們有一串有順序性的數組，要以何種形式存入記憶體呢？ 我們操作的虛擬記憶體就像是一格格的櫥窗，工程師在配置使用空間時有兩種常見的方式：
 配置一段連續的格子 (Array) 配置不連續的格子，並以額外的格子紀錄順序性 (Linked list)  With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory
     因為連續的記憶體是可以隨機存取(random access)的，導致兩種配置方式在資料操作上(e.g., 新增、刪除)的時間及空間成本各有不同。
Array vs. Linked list 兩者在記憶體的結構：
  Data storage scheme of an array
    Data storage scheme of a linked list
    Array：造訪第i個元素時因為是隨機存取所以時間複雜度是O(1)，但因為Array內的元素必須是連續的，移除第i個元素時必須將其後的元素通通往前移，因此為O(n)。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://nathan-tw.github.io/posts/linked-list/">
<meta property="og:image" content="http://nathan-tw.github.io/images/linked-list/linked.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-21T06:30:15-04:00">
<meta property="article:modified_time" content="2022-01-21T06:30:15-04:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="http://nathan-tw.github.io/images/linked-list/linked.jpg">
<meta name=twitter:title content="[技術] 深入淺出 linked list">
<meta name=twitter:description content="linked list 是什麼 假設我們有一串有順序性的數組，要以何種形式存入記憶體呢？ 我們操作的虛擬記憶體就像是一格格的櫥窗，工程師在配置使用空間時有兩種常見的方式：
 配置一段連續的格子 (Array) 配置不連續的格子，並以額外的格子紀錄順序性 (Linked list)  With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory
     因為連續的記憶體是可以隨機存取(random access)的，導致兩種配置方式在資料操作上(e.g., 新增、刪除)的時間及空間成本各有不同。
Array vs. Linked list 兩者在記憶體的結構：
  Data storage scheme of an array
    Data storage scheme of a linked list
    Array：造訪第i個元素時因為是隨機存取所以時間複雜度是O(1)，但因為Array內的元素必須是連續的，移除第i個元素時必須將其後的元素通通往前移，因此為O(n)。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://nathan-tw.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[技術] 深入淺出 linked list","item":"http://nathan-tw.github.io/posts/linked-list/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[技術] 深入淺出 linked list","name":"[技術] 深入淺出 linked list","description":"linked list 是什麼 假設我們有一串有順序性的數組，要以何種形式存入記憶體呢？ 我們操作的虛擬記憶體就像是一格格的櫥窗，工程師在配置使用空間時有兩種常見的方式：\n 配置一段連續的格子 (Array) 配置不連續的格子，並以額外的格子紀錄順序性 (Linked list)  With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory\n     因為連續的記憶體是可以隨機存取(random access)的，導致兩種配置方式在資料操作上(e.g., 新增、刪除)的時間及空間成本各有不同。\nArray vs. Linked list 兩者在記憶體的結構：\n  Data storage scheme of an array\n    Data storage scheme of a linked list\n    Array：造訪第i個元素時因為是隨機存取所以時間複雜度是O(1)，但因為Array內的元素必須是連續的，移除第i個元素時必須將其後的元素通通往前移，因此為O(n)。","keywords":[],"articleBody":"linked list 是什麼 假設我們有一串有順序性的數組，要以何種形式存入記憶體呢？ 我們操作的虛擬記憶體就像是一格格的櫥窗，工程師在配置使用空間時有兩種常見的方式：\n 配置一段連續的格子 (Array) 配置不連續的格子，並以額外的格子紀錄順序性 (Linked list)  With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory\n     因為連續的記憶體是可以隨機存取(random access)的，導致兩種配置方式在資料操作上(e.g., 新增、刪除)的時間及空間成本各有不同。\nArray vs. Linked list 兩者在記憶體的結構：\n  Data storage scheme of an array\n    Data storage scheme of a linked list\n    Array：造訪第i個元素時因為是隨機存取所以時間複雜度是O(1)，但因為Array內的元素必須是連續的，移除第i個元素時必須將其後的元素通通往前移，因此為O(n)。\n  Linked list：無法利用連續記憶體的隨機存取特性，造訪第i個元素時必須先造訪1至i-1，因此時間複雜度為O(n)，且因為必須以額外的指標做相連，使得存入相同的資料時較Array耗費空間。好處是空間配置較為彈性，刪除第i個節點時時間複雜度為O(1)，並且不需要在配置空間時固定長度。\n  比較兩者使用的空間及特性：\n   Linked List Array   空間 較複雜(需要額外pointer) 較節省   查詢第i個元素 O(n) O(1)   刪除第i個元素 O(1) O(n)   優點 大小可不固定 隨機存取   Dynamic Array 如果array大小固定，python中的list與go中的slice是如何實現？為何不須在一開始給定Array大小，也沒有剛剛提到的固定長度限制？ 其實他們都是維護一個Dynamic Array，簡單來說就是一個包含Array的類別或結構體，空間不夠時再抽換Array。以go為例，slice的結構如下：\ntype slice struct {  array unsafe.Pointer  len int  cap int } array是一個指向底層Array的指標，如果執行append時發現cap等於len則會擴容，也就是更換pointer。\n Linked list 與 pointer Linux開發者Linus Torvalds在2016的TED演講中提到了Linux的哲學，其中他舉了一個刪除Linked List節點的例子：\n   \n以刪除節點為例，考慮到移除第一個節點head需要做例外處理，因為移除第一個節點時沒有辦法以上一個節點出發：\nvoid remove_list_node(List *list, Node *target) {  Node *prev = NULL;  Node *current = list-head;  // Walk the list  while (current != target) {  prev = current;  current = current-next;  }  // Remove the target by updating the head or the previous node.  if (!prev)  list-head = target-next;  else  prev-next = target-next; } Linus認為有品味的作法是維護一個指向要更新的位址的indirect pointer，以「檢查某個位址是否需要被更新」的想法，程式碼將大大減少為4行：\nvoid remove_list_node(List *list, Node *target) {  Node **indirect = \u0026list-head;  while (*indirect != target)  indirect = \u0026(*indirect)-next;  *indirect = target-next; } 假設有A, B, C 三個節點相連，需要維護目前指標及上一個節點的指標，檢查目前指標是否為Target，如果是則更改上一個指標指向的值： 後者的想法則是以一個指標的指標順著指標走，尋找「需要被更新」的位址： Linux kernel 中的 linked list 我們常見的Linked list結構是將資料存放於結構體內，但Linux kernel的list_head卻不是這麼做：\n// usually struct list_node { \tint data; \tstruct list_node *next; }  // linux/scripts/kconfig/list.h struct list_head { \tstruct list_head *next, *prev; }; 使用方式如下：\nstruct student {  char name[16];  int id;  struct list_head list; }; 如果資料不在Linked list的結構體內，不就只能一直循環取不到資料了嗎？假設Tom的下個節點是Jerry，該如何取得Jerry的id？\nstruct list_node *Jerry_list = (Tom-list).next; 結構體連接示意圖：\n Linux kernel提供了一個很巧妙的macro container_of，只要知道結構體型別，就能以member的位置回推出他所在的container位置。 因此剛剛上面的例子可以用這種方式取得Jerry：\nstruct student {  char name[16];  int id;  struct list_head list; };  struct list_node *Jerry_list = (Tom-list).next; struct student *Jerry = container_of(jerry_list, struct student, list); 那container_of是如何實做的呢？我們先從另一個macro offsetof開始理解。\noffsetof 給定一個結構體student，要如何算出結構體與其成員的偏移呢？\nC89/C99 提供 offsetof 巨集，傳統上offsetof是這樣實做的：\n#define offsetof(TYPE, MEMBER) ((size_t) \u0026((TYPE *)0)-MEMBER) 將數值 0 強制轉型成TYPE指標型別，0 會被當作該TYPE的起始地址，因為起始位址等於 0 ，所以MEMBER的位址也就等於MEMBER與起始位址 0 的偏移(offset)。\noffsetof(struct student, id)); //16 container_of container_of的定義較為複雜：\n#define container_of(ptr, type, member) ({\\ const typeof( ((type *)0)-member ) *__mptr = (ptr);\\ (type *)( (char *)__mptr - offsetof(type,member));}) 可以拆解為兩部份，第一部份為：\nconst typeof( ((type *)0)-member ) *__mptr = (ptr); 利用ptr得到該member型態同值的__mptr， 以member是list為例就是x+20， (但目前不知道offset為20)。\n既然有了__mptr就輕鬆了，第二部份可以利用offsetof計算所在的結構體位置：\n(type *)( (char *)__mptr - offsetof(type,member)); 回頭看看Tom如何取得Jerry，利用struct student中的成員 list以offsetof取得Jerry的指標。\nstruct student *Jerry = container_of(Jerry_list, struct student, list); 一切便大功告成！這樣的方式使許多非連續記憶體的操作更廣泛使用，例如network address table及檔案系統的namespace等等。\n總結 Linked list 使用時機：\n 無法預期資料數量或頻繁變動資料數量時。 需要頻繁地新增/刪除資料時。 不需要快速查詢資料。  Reference  linked list vs. array: http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html#comp linked list vs. array: https://www.geeksforgeeks.org/linked-list-vs-array/ array and linked List: https://pjchender.dev/dsa/dsa-array-linked-list/ list_head 結構: http://adrianhuang.blogspot.com/2007/10/linux-kernel-listhead.html  ","wordCount":"362","inLanguage":"en","image":"http://nathan-tw.github.io/images/linked-list/linked.jpg","datePublished":"2022-01-21T06:30:15-04:00","dateModified":"2022-01-21T06:30:15-04:00","author":{"@type":"Person","name":"Nathan"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://nathan-tw.github.io/posts/linked-list/"},"publisher":{"@type":"Organization","name":"林宣佑 | Nathan Lin","logo":{"@type":"ImageObject","url":"http://nathan-tw.github.io/favicon.ico"}}}</script>
</head><body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header>
<nav class=nav>
<div class=logo>
<a href=http://nathan-tw.github.io/ accesskey=h title="林宣佑 | Nathan Lin (Alt + H)">林宣佑 | Nathan Lin</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div><ul id=menu>
<li>
<a href=http://nathan-tw.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li><li>
<a href=http://nathan-tw.github.io/about/ title=About>
<span>About</span>
</a>
</li></ul></nav></header><main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://nathan-tw.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://nathan-tw.github.io/posts/>Posts</a></div><h1 class=post-title>
[技術] 深入淺出 linked list
</h1><div class=post-meta>January 21, 2022&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Nathan
</div></header><figure class=entry-cover><img loading=lazy src=http://nathan-tw.github.io/images/linked-list/linked.jpg alt>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div></summary>
<div class=inner><ul>
<li>
<a href=#linked-list-%e6%98%af%e4%bb%80%e9%ba%bc aria-label="linked list 是什麼">linked list 是什麼</a><ul>
<li>
<a href=#array-vs-linked-list aria-label="Array vs. Linked list">Array vs. Linked list</a></li><li>
<a href=#dynamic-array aria-label="Dynamic Array">Dynamic Array</a></li></ul></li><li>
<a href=#linked-list-%e8%88%87-pointer aria-label="Linked list 與 pointer">Linked list 與 pointer</a></li><li>
<a href=#linux-kernel-%e4%b8%ad%e7%9a%84-linked-list aria-label="Linux kernel 中的 linked list">Linux kernel 中的 linked list</a><ul>
<li>
<a href=#offsetof aria-label=offsetof>offsetof</a></li><li>
<a href=#container_of aria-label=container_of>container_of</a></li></ul></li><li>
<a href=#%e7%b8%bd%e7%b5%90 aria-label=總結>總結</a></li><li>
<a href=#reference aria-label=Reference>Reference</a>
</li></ul></div></details>
</div><div class=post-content><h2 id=linked-list-是什麼>linked list 是什麼<a hidden class=anchor aria-hidden=true href=#linked-list-是什麼>#</a></h2><p>假設我們有一串有順序性的數組，要以何種形式存入記憶體呢？
我們操作的虛擬記憶體就像是一格格的櫥窗，工程師在配置使用空間時有兩種常見的方式：</p><ol>
<li>配置一段連續的格子 (Array)</li><li>配置不連續的格子，並以額外的格子紀錄順序性 (Linked list)
<blockquote>
<p>With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory</p></blockquote></li></ol><figure>
<img loading=lazy src=/images/linked-list/memory.png width=700>
</figure><p>因為連續的記憶體是可以隨機存取(random access)的，導致兩種配置方式在資料操作上(e.g., 新增、刪除)的時間及空間成本各有不同。</p><h3 id=array-vs-linked-list>Array vs. Linked list<a hidden class=anchor aria-hidden=true href=#array-vs-linked-list>#</a></h3><p>兩者在記憶體的結構：</p><figure>
<img loading=lazy src=/images/linked-list/array_data_schema.png width=700> <figcaption>
<p>Data storage scheme of an array</p></figcaption></figure><figure>
<img loading=lazy src=/images/linked-list/linkedlist_data_schema.png width=700> <figcaption>
<p>Data storage scheme of a linked list</p></figcaption></figure><ul>
<li>
<p>Array：造訪第i個元素時因為是隨機存取所以時間複雜度是O(1)，但因為Array內的元素必須是連續的，移除第i個元素時必須將其後的元素通通往前移，因此為O(n)。</p></li><li>
<p>Linked list：無法利用連續記憶體的隨機存取特性，造訪第i個元素時必須先造訪1至i-1，因此時間複雜度為O(n)，且因為必須以額外的指標做相連，使得存入相同的資料時較Array耗費空間。好處是空間配置較為彈性，刪除第i個節點時時間複雜度為O(1)，並且不需要在配置空間時固定長度。</p></li></ul><p>比較兩者使用的空間及特性：</p><table><tbody>
<tr>
<th style=width:228px></th><th>Linked List</th><th>Array</th></tr><tr>
<td style=width:228px>空間</td><td>較複雜(需要額外pointer)</td><td>較節省</td></tr><tr>
<td style=width:228px>查詢第i個元素</td><td>O(n)</td><td>O(1)</td></tr><tr>
<td>刪除第i個元素</td><td>O(1)</td><td>O(n)</td></tr><tr>
<td>優點</td><td>大小可不固定</td><td>隨機存取</td></tr></tbody></table><h3 id=dynamic-array>Dynamic Array<a hidden class=anchor aria-hidden=true href=#dynamic-array>#</a></h3><p>如果array大小固定，python中的list與go中的slice是如何實現？為何不須在一開始給定Array大小，也沒有剛剛提到的固定長度限制？
其實他們都是維護一個<a href=https://en.wikipedia.org/wiki/Dynamic_array>Dynamic Array</a>，簡單來說就是一個包含Array的類別或結構體，空間不夠時再抽換Array。以go為例，slice的結構如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>array</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>array</code>是一個指向底層Array的指標，如果執行<code>append</code>時發現<code>cap</code>等於<code>len</code>則會擴容，也就是更換pointer。</p><div class="sl-block is-focused" data-block-type=image data-name=image-09dfc7 style=width:489.224px;height:337.612px;left:445.085px;top:237.368px;min-width:1px;min-height:1px data-origin-id=e5ec20aa8b9d20867e8713bdf0a622b1><div class=sl-block-content style=z-index:12><img data-natural-width=626 data-natural-height=432 data-lazy-loaded src=https://s3.amazonaws.com/media-p.slid.es/uploads/1585165/images/9251604/WskKaXf.png></div></div><h2 id=linked-list-與-pointer>Linked list 與 pointer<a hidden class=anchor aria-hidden=true href=#linked-list-與-pointer>#</a></h2><p>Linux開發者<strong>Linus Torvalds</strong>在<a href="https://www.youtube.com/watch?v=o8NPllzkFhE">2016的TED演講</a>中提到了Linux的哲學，其中他舉了一個刪除Linked List節點的例子：</p><p>
<div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden>
<iframe src=https://www.youtube-nocookie.com/embed/o8NPllzkFhE style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe>
</div><br></p><img src=/images/linked-list/remove_node.png>
<p>以刪除節點為例，考慮到移除第一個節點<code>head</code>需要做例外處理，因為移除第一個節點時沒有辦法以上一個節點出發：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove_list_node</span>(List <span style=color:#f92672>*</span>list, Node <span style=color:#f92672>*</span>target)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>*</span>current <span style=color:#f92672>=</span> list<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Walk the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>!=</span> target) {
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Remove the target by updating the head or the previous node.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>prev)
</span></span><span style=display:flex><span>        list<span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> target<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> target<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Linus認為有品味的作法是維護一個指向要更新的位址的indirect pointer，以「檢查某個位址是否需要被更新」的想法，程式碼將大大減少為4行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove_list_node</span>(List <span style=color:#f92672>*</span>list, Node <span style=color:#f92672>*</span>target)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Node <span style=color:#f92672>**</span>indirect <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>list<span style=color:#f92672>-&gt;</span>head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>*</span>indirect <span style=color:#f92672>!=</span> target)
</span></span><span style=display:flex><span>        indirect <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>indirect)<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>indirect <span style=color:#f92672>=</span> target<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>假設有<code>A</code>, <code>B</code>, <code>C</code> 三個節點相連，需要維護目前指標及上一個節點的指標，檢查目前指標是否為Target，如果是則更改上一個指標指向的值：
<img src=/images/linked-list/direct.png></p><p>後者的想法則是以一個指標的指標順著指標走，尋找「需要被更新」的位址：
<img src=/images/linked-list/indirect.png></p><h2 id=linux-kernel-中的-linked-list>Linux kernel 中的 linked list<a hidden class=anchor aria-hidden=true href=#linux-kernel-中的-linked-list>#</a></h2><p>我們常見的Linked list結構是將資料存放於結構體內，但Linux kernel的<code>list_head</code>卻不是這麼做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// usually
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> list_node {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> list_node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// linux/scripts/kconfig/list.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> list_head {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>next, <span style=color:#f92672>*</span>prev;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>使用方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> student
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head list;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>如果資料不在Linked list的結構體內，不就只能一直循環取不到資料了嗎？假設Tom的下個節點是Jerry，該如何取得Jerry的id？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> list_node <span style=color:#f92672>*</span>Jerry_list <span style=color:#f92672>=</span> (Tom<span style=color:#f92672>-&gt;</span>list).next;
</span></span></code></pre></div><p>結構體連接示意圖：</p><div class="sl-block is-focused" data-block-type=image data-name=image-467510 style=width:560px;height:237.545px;left:183.693px;top:361.962px;min-width:1px;min-height:1px data-origin-id=d93128418da5740dfe459fa43a2706d6><div class=sl-block-content style=z-index:11><img data-natural-width=554 data-natural-height=235 data-lazy-loaded src=https://s3.amazonaws.com/media-p.slid.es/uploads/1585165/images/9254793/pasted-from-clipboard.png></div></div><p>Linux kernel提供了一個很巧妙的macro <code>container_of</code>，只要知道結構體型別，就能以member的位置回推出他所在的container位置。
因此剛剛上面的例子可以用這種方式取得Jerry：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> student
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head list;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> list_node <span style=color:#f92672>*</span>Jerry_list <span style=color:#f92672>=</span> (Tom<span style=color:#f92672>-&gt;</span>list).next;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>Jerry <span style=color:#f92672>=</span> container_of(jerry_list, <span style=color:#66d9ef>struct</span> student, list);
</span></span></code></pre></div><p>那<code>container_of</code>是如何實做的呢？我們先從另一個macro <code>offsetof</code>開始理解。</p><h3 id=offsetof>offsetof<a hidden class=anchor aria-hidden=true href=#offsetof>#</a></h3><p>給定一個結構體student，要如何算出結構體與其成員的偏移呢？</p><img src=/images/linked-list/struct.png width=300px>
<p>C89/C99 提供 offsetof 巨集，傳統上<code>offsetof</code>是這樣實做的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</span></span></span></code></pre></div><p>將數值 0 強制轉型成TYPE指標型別，0 會被當作該TYPE的起始地址，因為起始位址等於 0
，所以MEMBER的位址也就等於MEMBER與起始位址 0 的偏移(offset)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>offsetof(<span style=color:#66d9ef>struct</span> student, id)); <span style=color:#75715e>//16
</span></span></span></code></pre></div><h3 id=container_of>container_of<a hidden class=anchor aria-hidden=true href=#container_of>#</a></h3><p>container_of的定義較為複雜：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define container_of(ptr, type, member) ({\
</span></span></span><span style=display:flex><span><span style=color:#75715e>        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);\
</span></span></span><span style=display:flex><span><span style=color:#75715e>              (type *)( (char *)__mptr - offsetof(type,member));})
</span></span></span></code></pre></div><p>可以拆解為兩部份，第一部份為：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>typeof</span>( ((type <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0</span>)<span style=color:#f92672>-&gt;</span>member ) <span style=color:#f92672>*</span>__mptr <span style=color:#f92672>=</span> (ptr);
</span></span></code></pre></div><p>利用ptr得到該member型態同值的__mptr，
以member是list為例就是x+20，
(但目前不知道offset為20)。</p><p>既然有了__mptr就輕鬆了，第二部份可以利用<code>offsetof</code>計算所在的結構體位置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>(type <span style=color:#f92672>*</span>)( (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)__mptr <span style=color:#f92672>-</span> offsetof(type,member));
</span></span></code></pre></div><p>回頭看看Tom如何取得Jerry，利用<code>struct student</code>中的成員 <code>list</code>以<code>offsetof</code>取得Jerry的指標。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>Jerry <span style=color:#f92672>=</span> container_of(Jerry_list, <span style=color:#66d9ef>struct</span> student, list);
</span></span></code></pre></div><p>一切便大功告成！這樣的方式使許多非連續記憶體的操作更廣泛使用，例如<a href=https://github.com/torvalds/linux/blob/master/net/netlabel/netlabel_addrlist.h>network address table</a>及檔案系統的<a href=https://github.com/torvalds/linux/blob/master/fs/mount.h>namespace</a>等等。</p><h2 id=總結>總結<a hidden class=anchor aria-hidden=true href=#總結>#</a></h2><p>Linked list 使用時機：</p><ul>
<li>無法預期資料數量或頻繁變動資料數量時。</li><li>需要頻繁地新增/刪除資料時。</li><li>不需要快速查詢資料。</li></ul><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul>
<li>linked list vs. array: <a href=http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html#comp>http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html#comp</a></li><li>linked list vs. array: <a href=https://www.geeksforgeeks.org/linked-list-vs-array/>https://www.geeksforgeeks.org/linked-list-vs-array/</a></li><li>array and linked List: <a href=https://pjchender.dev/dsa/dsa-array-linked-list/>https://pjchender.dev/dsa/dsa-array-linked-list/</a></li><li>list_head 結構: <a href=http://adrianhuang.blogspot.com/2007/10/linux-kernel-listhead.html>http://adrianhuang.blogspot.com/2007/10/linux-kernel-listhead.html</a></li></ul></div><footer class=post-footer>
<nav class=paginav>
<a class=next href=http://nathan-tw.github.io/posts/university/>
<span class=title>Next Page »</span>
<br>
<span>[生活] 夏夜夢迴</span>
</a>
</nav></footer><div class="disqus markdown">
<div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://star67.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></article></main><footer class=footer>
<span>&copy; 2022 <a href=http://nathan-tw.github.io/>林宣佑 | Nathan Lin</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script>
</body></html>